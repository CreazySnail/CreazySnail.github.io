<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on creazy snail</title>
    <link>https://creazysnail.github.io/post/</link>
    <description>Recent content in Posts on creazy snail</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 24 Apr 2021 16:42:32 +0800</lastBuildDate><atom:link href="https://creazysnail.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Disruptor使用</title>
      <link>https://creazysnail.github.io/post/disruptor%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 24 Apr 2021 16:42:32 +0800</pubDate>
      
      <guid>https://creazysnail.github.io/post/disruptor%E4%BD%BF%E7%94%A8/</guid>
      <description>前言: Disruptor是英国外汇交易公司LMAX开发的一个高性能队列，用于解决内存队列延迟问题；在学习过程中发现网上资料不全，故整理demo如下。
 maven引入  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.lmax&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;disruptor&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.4.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 元素类 public class Element { private int value; public int get() { return value; } public void set(int value) { this.value = value; } } 广播模式  EventFactory&amp;lt;Element&amp;gt; eventFactory = () -&amp;gt; new Element(); int bufferSize = 16; ThreadFactory threadFactory = r -&amp;gt; new Thread(r, &amp;quot;consumer thread&amp;quot;); BlockingWaitStrategy strategy = new BlockingWaitStrategy(); Disruptor&amp;lt;Element&amp;gt; disruptor = new Disruptor(eventFactory, bufferSize, threadFactory, ProducerType.</description>
    </item>
    
    <item>
      <title>ThreadLocal分析</title>
      <link>https://creazysnail.github.io/post/threadlocal%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 24 Apr 2021 11:46:52 +0800</pubDate>
      
      <guid>https://creazysnail.github.io/post/threadlocal%E5%88%86%E6%9E%90/</guid>
      <description>前言 ThreadLocal是我们在写Java代码中常用的一个类，我们用它保存跨多个方法的变量。
举例，方法A调用方法B，方法B调用方法C，方法C需要方法A的一个参数，如果通过方法入参传递，需要修改方法B、方法C的入参，使用ThreadLocal后，只需要在方法A set，方法C get即可。
相关类 ThreadLocalMap 专门为线程本地变量定制的Map；与此对应，Thread对象中有一个参数对应该类。
 ThreadLocal.ThreadLocalMap threadLocals = null; Entry 继承WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;raquo;，这样当key也就是ThreadLocal在Entry之外没有强引用之后，可以被gc回收。
 public static void main(String[] args) { String uuid = UUID.randomUUID().toString(); WeakReference&amp;lt;String&amp;gt; b = new WeakReference&amp;lt;&amp;gt;(uuid); System.gc(); System.out.println(uuid); // xxx System.out.println(b.get()); // xxx System.out.println(&amp;quot;---&amp;quot;); uuid = null; System.gc(); System.out.println(uuid); // null System.out.println(b.get()); // null } 可以看到，当我们把uuid强引用移除且gc后，uuid会被回收，不会因为b中key指向uuid而继续存在。
问题 ThreadLocal是否线程安全？ ThreadLocal是线程安全的。
 ThreadLocal&amp;lt;Object&amp;gt; local = new ThreadLocal&amp;lt;&amp;gt;(); local.set(&amp;quot;a&amp;quot;); public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map !</description>
    </item>
    
  </channel>
</rss>
